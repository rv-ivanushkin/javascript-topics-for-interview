# Сборка мусора | Как происходит сборка ненужных объектов?

## Содержание

- [В самом начале: мусор и живой объект](#в-самом-начале-мусор-и-живой-объект)
- [Какой тип сборки мусора используется в JavaScript?](#какой-тип-сборки-мусора-используется-в-javascript)
- [Что нужно помнить о сборщике мусора в JavaScript](#что-нужно-помнить-о-сборщике-мусора-в-javascript)

## В самом начале: мусор и живой объект

Для начала банально но, стоит сказать о мусоре

> Мусор - всё, что не является живым объектом.

А что такое `живой объект`?

> Живой объект — такой объект, до которого можно дойти по ссылкам от корневого объекта.

Здесь я предлагаю сделать паузу и просто подумать о том, что:

- Все то, что можно использовать или находится в зоне доступа по `ссылкам`, будет считаться `живой объект`
- Все остальное мусор

Что значит доступно?

Я бы переформулировал вопрос - доступно относительно чего?

И тут сразу все стает на свои места, так как всегда есть `Root` или корневой объект, с которого начинается.

Теперь возьмем и создадим объект, прям в `console`

```js
const mySupeObject = {
  name: "Roman",
  power: "Fire"
}
```

Теперь остается понять, а где же этот объект находится?

<img src="../assets/garbage.collect.0.png">

Отлично, область видимости - `Script`, теперь можно предположить, что у глобального "Script Root" есть ссылка на `mySupeObject`, значит это живой объект и удалять его не стоит

## Какой тип сборки мусора используется в JavaScript?

> Главной концепцией управления памятью в JavaScript является принцип достижимости (англ. reachability).

Здесь все достаточно просто, если не углубляться в детали оптимизации

Если ссылки на объект от корневого (в нейкой последовательности) существуют, то такой объект не является мусором

> Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Алгоритм работы:

1. Пометить все корневые объекты
1. Пометить все ссылки для каждого из объектов на шаге 1.
1. "Запоминание" пройденных объектов и ссылок
1. Возврат к шагу 1.

Все не помеченные объекты удаляются

> Движки JavaScript применяют множество оптимизаций:
>
> - Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
> - Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнения скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
> - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

## Что нужно помнить о сборщике мусора в JavaScript?

- Процесс сборки мусора автоматический, что значит без контрольный для разработчика
- В памяти хранятся только `достижимые` или `живые объекты` объекты

## Источник данных

- [Сборка мусора](https://habr.com/ru/company/ruvds/blog/337460/)
- [garbage.collect()](https://habr.com/ru/company/oleg-bunin/blog/433318/)
- [Достижимость объекта](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0#%D0%94%D0%BE%D1%81%D1%82%D0%B8%D0%B6%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)