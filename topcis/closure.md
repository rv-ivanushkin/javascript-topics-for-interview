# Что такое замыкание и как оно работает?

## Содержание

- [Определения из интернета](#определения-из-интернета)
- [Формируем свое определение](#простое-определение-замыкания)
- [Как работает замыкание](#как-работает-замыкание)
- [Примечание к определениям из интернета](#примечания)
- [Исключение](#исключение)
- [источники-данных](#источники-данных)

## Определения из интернета

Самое первое определение из поиска

> Замыкание - это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция завершила свою работу

На сайте mozilla дано чуток иное определение

> Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

Или вот еще

> Замыкание — это функция, у которой есть доступ к области видимости, сформированной внешней по отношению к ней функции даже после того, как эта внешняя функция завершила работу. Это значит, что в замыкании могут храниться переменные, объявленные во внешней функции и переданные ей аргументы.

&#128552; &#128561; Везде разными словами об одном и том же

## Пример

Для начала простой пример на тему замыкание

```js
function makeCounter(defaultCount = 0) {
  let count = defaultCount;
  
  // просто увеличиваем на 1
  const increaseCount = () => ++count
  
  // просто увеличиваем на 10
  const increaseCountOnTen = () => count += 10

  // просто задаем значение по defaultCount
  const setCountByDefault = () => {
    count = defaultCount
  }

  return [increaseCount, increaseCountOnTen, setCountByDefault]
}

let [increaseCount, increase10Count, resetCount] = makeCounter()

console.log(increaseCount()) // выведет 1
console.log(increaseCount()) // выведет 2
console.log(increaseCount()) // выведет 3
console.log(increaseCount()) // выведет 4

console.log(increase10Count()) // выведет 14

resetCount()

console.log(increase10Count()) // выведет 10
```

Если посмотреть на пример, то можно выделить следующее

- Есть функция `makeCounter`, которая возвращает массив с ссылками на функции
- Есть переменная `defaultCount` и `count`, где первая это значение по умолчанию, а последнее - сам счетчик
- Есть три функции `increaseCount, increaseCountOnTen, setCountByDefault`, которые что-то делают
- Есть результат, где самое важно - получить доступ к count "невозможно" на прямую, только через `helpers`

## Простое определение замыкания

> Замыкание - это такая **функция**, которая возвращают **объявленную внутри нее другую функцию** и эта функция имеет доступ ко всей выше стоящей **области видимости, включая аргументы функции**.

## Как работает замыкание?

Для начала определения

> Область видимости - структура данных, которая определяет, к каким переменным функция, команда или другая переменная может получить доступ, а к каким нет.

Лексическое область видимости или "окружение"

> Лексическое окружение — это структура данных, которая хранит сведения о соответствии идентификаторов и переменных.
>
>Где:
>
>- «идентификатор» — это имя переменной или функции
>- «переменная» — это ссылка на объект (сюда входят и функции) или значение примитивного типа.

## Самое главное помнить о том, что все "крутится" вокруг функции и того, что находится внутри `{}`

```js
// Глобальная по отношению к makeCounter область видимости
function makeCounter(defaultCount = 0) {
  // локальная область видимости, ограниченная {}

  // Глобальная по отношению к encapsulation область видимости
  return function encapsulation(){
    // локальная область видимости, ограниченная {}
  }
}
```

Все это можно представить как

```js
lexicalEnvironment = {
  environmentRecord: {
    <identifier> : <value>,
    <identifier> : <value>
  }
  outer: < Reference to the parent lexical environment>
}
```

Таким образом, функция `encapsulation` возвращаемая из функции `makeCounter` имеет доступ (по ссылки `outer`) к тому, что находится внутри `{}`

### Примечания

Однажды я прочитал вот такое определение на medium

> Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась.

И глагол `прекратилась` ввела меня в ступор, так как я не понял, что это значит.
Мне кажется, что именно этот глагол и является проблемой столь большого количества определений.

Каждый, кто пытается понять замыкание думает именно о том, что:

- функция завершила свое выполнение и как же тогда у нее есть доступ к переменные внутри другой функции?

Наверное вопрос просто не правильно задан

## Исключение

Есть очень интересное исключение для функции созданной через оператор `new Function`

```js
function makeCounter(defaultCount = 0) {
  let count = defaultCount;
  
  return new Function() {
    ++count
  }
}

let increaseCount = makeCounter()

console.log(increaseCount()) //  Uncaught TypeError: increaseCount is not a function
```

> когда функция создаётся с использованием new Function, в её лексическое окружение (в частности `outer`) записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.

## Источники данных

- [Замыкание на medium](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898)
- [Замыкание на habr, вариант 1](https://habr.com/ru/company/ruvds/blog/424967/)
- [Замыкание на habr, вариант 2](https://habr.com/ru/post/474852/)
- [Замыкание на learn.javascript](https://learn.javascript.ru/closure)
- [Исключение в замыкании](https://learn.javascript.ru/new-function)
