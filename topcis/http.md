# Всё что нужно знать про HTTP

## Простой запрос через методы HEAD и GET

Я решил, что для полного понимания или же вспоминания данной темы лучше идти по шагам

И так шаг первый - Простой запрос через методы HEAD и GET

- GET - Используется для запроса содержимого указанного ресурса.
- HEAD - Все тоже самое что и GET, но только без тела

> тело запроса - полезная нагрузка ради которой и делаются эти запросы

Отправляем запрос через - `telnet httpbin.org 80`

```js
GET / HTTP/1.0           // [Метод] [URL] [Версия протокола]
Host: httpbin.org   // Хост, данные, которого нам необходимы
                         // 1 перевод строки
                         // 2 перевод строки
```

Получаем ответ

```js
HTTP/1.1 200 OK
Date: Sat, 01 Apr 2023 15:17:37 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 9593
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

<!DOCTYPE html>
<html lang="en">
....
</html>
```

Отлично, а теперь просто HEAD 

```js
HEAD / HTTP/1.0           // [Метод] [URL] [Версия протокола]
Host: httpbin.org   // Хост, данные, которого нам необходимы
                         // 1 перевод строки
                         // 2 перевод строки
```

Получаем ответ

```js
HTTP/1.1 200 OK
Date: Sat, 01 Apr 2023 15:19:56 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 9593
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

Connection closed by foreign host.
```

Все тоже самое, но только без тела, который отделяется переводом строки

Разберем теперь ответ:

Самым главным в ответе - первая строка

`HTTP/1.1 200 OK`:

- `HTTP/1.1` - протокол
- `200` - Код состояния или [Status Code](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0#%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D1%81_%D0%B2%D0%B5%D0%B1-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC_(HTTP))
- `OK` - Пояснение или Reason Phrase, текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

Далее сервер выдает "стандартные" заголовки, такие как дата, тип контента и т.д.

Что по итогу на данный момент?

> - Для запроса **необходимо**
>   - Метод протокола
>   - URL ресурса
>   - Версия протокола
>   - запрашиваемый хост
>   - два перевода строки

## Отправка данных через метод POST

Теперь шаг второй, где необходимо уже обмениваться данным с сервером

Открываем так же `telnet httpbin.org 80` и отправляем следующий запрос

```js
POST /post HTTP/1.1
Host: httpbin.org
Connection: close
Connection-type: application/json
Content-length: 14

{"hello":"very nice"}
```

Прежде чем продолжить, стоит отметить важную особенность при отправки этого запрос

> Для отправки этого запрос использовался заголовок `Content-length: 14`, который сообщает серверу то, что он должен ответить, только после того как длина "посимвольная в данном случае" будет равна `14`

После этого сервер автоматически вернет ответ

```js
HTTP/1.1 200 OK
Date: Sat, 01 Apr 2023 15:43:32 GMT
Content-Type: application/json
Content-Length: 353
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

{
  "args": {}, 
  "data": "{\"hello\":\"very", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Connection-Type": "application/json", 
    "Content-Length": "14", 
    "Host": "httpbin.org", 
    "X-Amzn-Trace-Id": "Root=1-6428510e-18890d92565c7ba45e38c3de"
  }, 
  "json": null, 
  "origin": "91.184.253.232", 
  "url": "http://httpbin.org/post"
}
Connection closed by foreign host.

```

Теперь становится понятно, что для каждого метода могут быть разные или специфичные заголовки для "полезного" обмена данными с сервером.

[Все методы HTTP](https://ru.wikipedia.org/wiki/HTTP#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B)

## Set-Cookie

> Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок Set-Cookie. Куки обычно запоминаются браузером и посылаются в HTTP-заголовке Cookie (en-US) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.

Т.е. сервер может передать клиенту данные для Cookie, которые нужно сохранить, а как клиент передает Cookie?

Все очень просто

```js
Cookie: <cookie-list>
Cookie: name=value
Cookie: name=value; name2=value2; name3=value3
```

Например - `Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1`

## Secure и HttpOnly

Если необходимо передавать `Cookie` только при использование протокола SSL и HTTPS, то есть два специальных ключа - Secure и HttpOnly

Например - `Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

## CORS

Источник идентифицируется тремя параметрами

- Схемой или протоколом
- Хостом
- Портом

Если хоть один из выше описанных параметров отличается, что это разные источники.

Про это на данный момент просто нужно помнить.

А теперь проблема:

- Когда браузер загрузил первые данные и начинает загружать такие теги как `<img>`, `<script>`, `<frame>`, `<video>`, `<audio>`, `<iframe>`, `<link>`, `<form>`

Это значит, если клиента ранее был на каких-то ресурсах, где используется `Cookie`, то их можно получить без проблем на стороннем сайта, а политика CORS это не позволяет.

> Политика одинакового источника предотвращает cross-origin атаки, блокируя доступ для прочтения загружаемых ресурсов из другого источника. Такая политика все еще разрешает нескольким тегам вроде <img> загружать ресурсы из других источников.

## Пример явного CORS

Предположим, что есть echo сервер, который возвращает все, что ему приходит

Пример для получение ошибки CORS:

1. Открываем браузер и загружаем `http://localhost:80/`
1. Отправляем запрос `POST` на `http://localhost:80/` прямо из console
    - Ответ будет получен и ошибок не будет
1. Теперь отправим запрос `POST` на `https://google.com` прямо из console
    - Получаем ошибку - CORS и красную console

Что тут важно?

А важно тут то, что браузер перед отправкой данных на "другой" источник сделал одно интересный запрос - браузер отправил запрос с методом `OPTIONS`, где предварительно проверят можно ли выполнить  запрос с данными из разных источников

Очень важно запомнить
> Браузер проверят можно ли выполнить  запрос с данными из разных источников

Выполняя запрос OPTIONS, вы должны помнить, что предварительный запрос браузера проверяет наличие трех заголовков, которые могут быть в ответе:

- `Access-Control-Allow-Methods`, который указывает на то, какие методы поддерживаются URL-ом ответа в контексте CORS протокола
- `Access-Control-Allow-Headers`, который указывает, на то, какие заголовки поддерживаются URL-ом ответа в контексте CORS протокола
- `Access-Control-Max-Age`, который указывает число секунд (5 по умолчанию) и это значение соответствует периоду, на который предоставляемая заголовками `Access-Control-Allow-Methods` и `Access-Control-Allow-Headers` информация может быть кэширована

## Источники данных

- [CORS: история возникновения, как устроен и оптимальные методы работы](https://habr.com/ru/company/macloud/blog/553826/)
- [Куки, document.cookie](https://learn.javascript.ru/cookie)
- [HTTP-куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies)
- [HTTP](https://ru.wikipedia.org/wiki/HTTP)
- [Всё что нужно знать про HTTP](https://medium.com/@twanttobealighi/%D0%B2%D1%81%D1%91-%D1%87%D1%82%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%BE-http-75567dad34c)